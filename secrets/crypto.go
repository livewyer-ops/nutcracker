package secrets

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"golang.org/x/crypto/nacl/box"
	"io"
)

type Secret struct {
	Name  string
	Nonce *[24]byte // 24 byte length mandated by NaCL.
	Src   *[32]byte // 32 byte length mandated by NaCL.
	Dst   *[32]byte // 32 byte length mandated by NaCL.
	Box   []byte
}

// New creates a new secret container with a unique key.
func New(name string) (s *Secret, key []byte, err error) {

	s = new(Secret)

	s.Name = name

	// We generate nonces randomly - chance of collision is negligable
	s.Nonce = new([24]byte)
	_, err = io.ReadFull(rand.Reader, s.Nonce[:])
	if err != nil {
		return
	}

	pub, priv, err := box.GenerateKey(rand.Reader)
	if err != nil {
		return
	}

	key = encode(priv[:])
	Zero(priv[:])

	s.Dst = pub
	return
}

// Encrypt adds an encrypted message to a secret container.
func (s *Secret) Encrypt(pub, priv *[32]byte, message []byte) (err error) {
	defer Zero(message)
	defer Zero(priv[:])

	s.Src = pub

	s.Box = box.Seal(nil, message, s.Nonce, s.Dst, priv)
	return
}

// Decrypt returns the decrypted message from a secret container,
// using the key generated by New()
func (s *Secret) Decrypt(key []byte) (message []byte, err error) {
	defer Zero(key)

	priv, err := decode(key)
	if err != nil {
		return
	}

	message, ok := box.Open(nil, s.Box, s.Nonce, s.Src, priv)
	if !ok {
		err = errors.New("Unable to decrypt secret")
	}
	return
}

// Zero wipes a byte slice in memory
func Zero(in []byte) {
	for i := range in {
		in[i] ^= in[i]
	}
}

func encode(in []byte) (out []byte) {
	encLen := base64.URLEncoding.EncodedLen(len(in))

	out = make([]byte, encLen, encLen)
	base64.URLEncoding.Encode(out, in)
	return
}

func decode(in []byte) (out *[32]byte, err error) {
	out = new([32]byte)
	// We can't check the length as base64 has an irritating
	// habit of appending null bytes
	buf := make([]byte, base64.URLEncoding.DecodedLen(len(in)))

	_, err = base64.URLEncoding.Decode(buf, in)

	copy(out[:], buf[0:32])
	Zero(buf)
	return
}
